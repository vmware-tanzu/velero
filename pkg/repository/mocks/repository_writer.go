// Code generated by mockery v2.22.1. DO NOT EDIT.

package mocks

import (
	context "context"

	index "github.com/kopia/kopia/repo/content/index"
	manifest "github.com/kopia/kopia/repo/manifest"

	mock "github.com/stretchr/testify/mock"

	object "github.com/kopia/kopia/repo/object"

	repo "github.com/kopia/kopia/repo"

	time "time"
)

// RepositoryWriter is an autogenerated mock type for the RepositoryWriter type
type RepositoryWriter struct {
	mock.Mock
}

// ClientOptions provides a mock function with given fields:
func (_m *RepositoryWriter) ClientOptions() repo.ClientOptions {
	ret := _m.Called()

	var r0 repo.ClientOptions
	if rf, ok := ret.Get(0).(func() repo.ClientOptions); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(repo.ClientOptions)
	}

	return r0
}

// Close provides a mock function with given fields: ctx
func (_m *RepositoryWriter) Close(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConcatenateObjects provides a mock function with given fields: ctx, objectIDs
func (_m *RepositoryWriter) ConcatenateObjects(ctx context.Context, objectIDs []object.ID) (object.ID, error) {
	ret := _m.Called(ctx, objectIDs)

	var r0 object.ID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []object.ID) (object.ID, error)); ok {
		return rf(ctx, objectIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []object.ID) object.ID); ok {
		r0 = rf(ctx, objectIDs)
	} else {
		r0 = ret.Get(0).(object.ID)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []object.ID) error); ok {
		r1 = rf(ctx, objectIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ContentInfo provides a mock function with given fields: ctx, contentID
func (_m *RepositoryWriter) ContentInfo(ctx context.Context, contentID index.ID) (index.Info, error) {
	ret := _m.Called(ctx, contentID)

	var r0 index.Info
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, index.ID) (index.Info, error)); ok {
		return rf(ctx, contentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, index.ID) index.Info); ok {
		r0 = rf(ctx, contentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(index.Info)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, index.ID) error); ok {
		r1 = rf(ctx, contentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteManifest provides a mock function with given fields: ctx, id
func (_m *RepositoryWriter) DeleteManifest(ctx context.Context, id manifest.ID) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, manifest.ID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FindManifests provides a mock function with given fields: ctx, labels
func (_m *RepositoryWriter) FindManifests(ctx context.Context, labels map[string]string) ([]*manifest.EntryMetadata, error) {
	ret := _m.Called(ctx, labels)

	var r0 []*manifest.EntryMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, map[string]string) ([]*manifest.EntryMetadata, error)); ok {
		return rf(ctx, labels)
	}
	if rf, ok := ret.Get(0).(func(context.Context, map[string]string) []*manifest.EntryMetadata); ok {
		r0 = rf(ctx, labels)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*manifest.EntryMetadata)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, map[string]string) error); ok {
		r1 = rf(ctx, labels)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Flush provides a mock function with given fields: ctx
func (_m *RepositoryWriter) Flush(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetManifest provides a mock function with given fields: ctx, id, data
func (_m *RepositoryWriter) GetManifest(ctx context.Context, id manifest.ID, data interface{}) (*manifest.EntryMetadata, error) {
	ret := _m.Called(ctx, id, data)

	var r0 *manifest.EntryMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, manifest.ID, interface{}) (*manifest.EntryMetadata, error)); ok {
		return rf(ctx, id, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, manifest.ID, interface{}) *manifest.EntryMetadata); ok {
		r0 = rf(ctx, id, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*manifest.EntryMetadata)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, manifest.ID, interface{}) error); ok {
		r1 = rf(ctx, id, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewObjectWriter provides a mock function with given fields: ctx, opt
func (_m *RepositoryWriter) NewObjectWriter(ctx context.Context, opt object.WriterOptions) object.Writer {
	ret := _m.Called(ctx, opt)

	var r0 object.Writer
	if rf, ok := ret.Get(0).(func(context.Context, object.WriterOptions) object.Writer); ok {
		r0 = rf(ctx, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(object.Writer)
		}
	}

	return r0
}

// NewWriter provides a mock function with given fields: ctx, opt
func (_m *RepositoryWriter) NewWriter(ctx context.Context, opt repo.WriteSessionOptions) (context.Context, repo.RepositoryWriter, error) {
	ret := _m.Called(ctx, opt)

	var r0 context.Context
	var r1 repo.RepositoryWriter
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, repo.WriteSessionOptions) (context.Context, repo.RepositoryWriter, error)); ok {
		return rf(ctx, opt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repo.WriteSessionOptions) context.Context); ok {
		r0 = rf(ctx, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repo.WriteSessionOptions) repo.RepositoryWriter); ok {
		r1 = rf(ctx, opt)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(repo.RepositoryWriter)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, repo.WriteSessionOptions) error); ok {
		r2 = rf(ctx, opt)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// OnSuccessfulFlush provides a mock function with given fields: callback
func (_m *RepositoryWriter) OnSuccessfulFlush(callback repo.RepositoryWriterCallback) {
	_m.Called(callback)
}

// OpenObject provides a mock function with given fields: ctx, id
func (_m *RepositoryWriter) OpenObject(ctx context.Context, id object.ID) (object.Reader, error) {
	ret := _m.Called(ctx, id)

	var r0 object.Reader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, object.ID) (object.Reader, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, object.ID) object.Reader); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(object.Reader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, object.ID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PrefetchContents provides a mock function with given fields: ctx, contentIDs, hint
func (_m *RepositoryWriter) PrefetchContents(ctx context.Context, contentIDs []index.ID, hint string) []index.ID {
	ret := _m.Called(ctx, contentIDs, hint)

	var r0 []index.ID
	if rf, ok := ret.Get(0).(func(context.Context, []index.ID, string) []index.ID); ok {
		r0 = rf(ctx, contentIDs, hint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]index.ID)
		}
	}

	return r0
}

// PrefetchObjects provides a mock function with given fields: ctx, objectIDs, hint
func (_m *RepositoryWriter) PrefetchObjects(ctx context.Context, objectIDs []object.ID, hint string) ([]index.ID, error) {
	ret := _m.Called(ctx, objectIDs, hint)

	var r0 []index.ID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []object.ID, string) ([]index.ID, error)); ok {
		return rf(ctx, objectIDs, hint)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []object.ID, string) []index.ID); ok {
		r0 = rf(ctx, objectIDs, hint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]index.ID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []object.ID, string) error); ok {
		r1 = rf(ctx, objectIDs, hint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutManifest provides a mock function with given fields: ctx, labels, payload
func (_m *RepositoryWriter) PutManifest(ctx context.Context, labels map[string]string, payload interface{}) (manifest.ID, error) {
	ret := _m.Called(ctx, labels, payload)

	var r0 manifest.ID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, map[string]string, interface{}) (manifest.ID, error)); ok {
		return rf(ctx, labels, payload)
	}
	if rf, ok := ret.Get(0).(func(context.Context, map[string]string, interface{}) manifest.ID); ok {
		r0 = rf(ctx, labels, payload)
	} else {
		r0 = ret.Get(0).(manifest.ID)
	}

	if rf, ok := ret.Get(1).(func(context.Context, map[string]string, interface{}) error); ok {
		r1 = rf(ctx, labels, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Refresh provides a mock function with given fields: ctx
func (_m *RepositoryWriter) Refresh(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ReplaceManifests provides a mock function with given fields: ctx, labels, payload
func (_m *RepositoryWriter) ReplaceManifests(ctx context.Context, labels map[string]string, payload interface{}) (manifest.ID, error) {
	ret := _m.Called(ctx, labels, payload)

	var r0 manifest.ID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, map[string]string, interface{}) (manifest.ID, error)); ok {
		return rf(ctx, labels, payload)
	}
	if rf, ok := ret.Get(0).(func(context.Context, map[string]string, interface{}) manifest.ID); ok {
		r0 = rf(ctx, labels, payload)
	} else {
		r0 = ret.Get(0).(manifest.ID)
	}

	if rf, ok := ret.Get(1).(func(context.Context, map[string]string, interface{}) error); ok {
		r1 = rf(ctx, labels, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Time provides a mock function with given fields:
func (_m *RepositoryWriter) Time() time.Time {
	ret := _m.Called()

	var r0 time.Time
	if rf, ok := ret.Get(0).(func() time.Time); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	return r0
}

// UpdateDescription provides a mock function with given fields: d
func (_m *RepositoryWriter) UpdateDescription(d string) {
	_m.Called(d)
}

// VerifyObject provides a mock function with given fields: ctx, id
func (_m *RepositoryWriter) VerifyObject(ctx context.Context, id object.ID) ([]index.ID, error) {
	ret := _m.Called(ctx, id)

	var r0 []index.ID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, object.ID) ([]index.ID, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, object.ID) []index.ID); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]index.ID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, object.ID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewRepositoryWriter interface {
	mock.TestingT
	Cleanup(func())
}

// NewRepositoryWriter creates a new instance of RepositoryWriter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewRepositoryWriter(t mockConstructorTestingTNewRepositoryWriter) *RepositoryWriter {
	mock := &RepositoryWriter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
