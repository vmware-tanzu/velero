// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"time"

	"github.com/kopia/kopia/repo"
	"github.com/kopia/kopia/repo/content"
	"github.com/kopia/kopia/repo/manifest"
	"github.com/kopia/kopia/repo/object"
	mock "github.com/stretchr/testify/mock"
)

// NewMockRepository creates a new instance of MockRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRepository {
	mock := &MockRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRepository is an autogenerated mock type for the Repository type
type MockRepository struct {
	mock.Mock
}

type MockRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRepository) EXPECT() *MockRepository_Expecter {
	return &MockRepository_Expecter{mock: &_m.Mock}
}

// ClientOptions provides a mock function for the type MockRepository
func (_mock *MockRepository) ClientOptions() repo.ClientOptions {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ClientOptions")
	}

	var r0 repo.ClientOptions
	if returnFunc, ok := ret.Get(0).(func() repo.ClientOptions); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(repo.ClientOptions)
	}
	return r0
}

// MockRepository_ClientOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientOptions'
type MockRepository_ClientOptions_Call struct {
	*mock.Call
}

// ClientOptions is a helper method to define mock.On call
func (_e *MockRepository_Expecter) ClientOptions() *MockRepository_ClientOptions_Call {
	return &MockRepository_ClientOptions_Call{Call: _e.mock.On("ClientOptions")}
}

func (_c *MockRepository_ClientOptions_Call) Run(run func()) *MockRepository_ClientOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRepository_ClientOptions_Call) Return(clientOptions repo.ClientOptions) *MockRepository_ClientOptions_Call {
	_c.Call.Return(clientOptions)
	return _c
}

func (_c *MockRepository_ClientOptions_Call) RunAndReturn(run func() repo.ClientOptions) *MockRepository_ClientOptions_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function for the type MockRepository
func (_mock *MockRepository) Close(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockRepository_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) Close(ctx interface{}) *MockRepository_Close_Call {
	return &MockRepository_Close_Call{Call: _e.mock.On("Close", ctx)}
}

func (_c *MockRepository_Close_Call) Run(run func(ctx context.Context)) *MockRepository_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockRepository_Close_Call) Return(err error) *MockRepository_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_Close_Call) RunAndReturn(run func(ctx context.Context) error) *MockRepository_Close_Call {
	_c.Call.Return(run)
	return _c
}

// ContentInfo provides a mock function for the type MockRepository
func (_mock *MockRepository) ContentInfo(ctx context.Context, contentID content.ID) (content.Info, error) {
	ret := _mock.Called(ctx, contentID)

	if len(ret) == 0 {
		panic("no return value specified for ContentInfo")
	}

	var r0 content.Info
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, content.ID) (content.Info, error)); ok {
		return returnFunc(ctx, contentID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, content.ID) content.Info); ok {
		r0 = returnFunc(ctx, contentID)
	} else {
		r0 = ret.Get(0).(content.Info)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, content.ID) error); ok {
		r1 = returnFunc(ctx, contentID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_ContentInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContentInfo'
type MockRepository_ContentInfo_Call struct {
	*mock.Call
}

// ContentInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - contentID content.ID
func (_e *MockRepository_Expecter) ContentInfo(ctx interface{}, contentID interface{}) *MockRepository_ContentInfo_Call {
	return &MockRepository_ContentInfo_Call{Call: _e.mock.On("ContentInfo", ctx, contentID)}
}

func (_c *MockRepository_ContentInfo_Call) Run(run func(ctx context.Context, contentID content.ID)) *MockRepository_ContentInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 content.ID
		if args[1] != nil {
			arg1 = args[1].(content.ID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_ContentInfo_Call) Return(v content.Info, err error) *MockRepository_ContentInfo_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockRepository_ContentInfo_Call) RunAndReturn(run func(ctx context.Context, contentID content.ID) (content.Info, error)) *MockRepository_ContentInfo_Call {
	_c.Call.Return(run)
	return _c
}

// FindManifests provides a mock function for the type MockRepository
func (_mock *MockRepository) FindManifests(ctx context.Context, labels map[string]string) ([]*manifest.EntryMetadata, error) {
	ret := _mock.Called(ctx, labels)

	if len(ret) == 0 {
		panic("no return value specified for FindManifests")
	}

	var r0 []*manifest.EntryMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, map[string]string) ([]*manifest.EntryMetadata, error)); ok {
		return returnFunc(ctx, labels)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, map[string]string) []*manifest.EntryMetadata); ok {
		r0 = returnFunc(ctx, labels)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*manifest.EntryMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, map[string]string) error); ok {
		r1 = returnFunc(ctx, labels)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_FindManifests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindManifests'
type MockRepository_FindManifests_Call struct {
	*mock.Call
}

// FindManifests is a helper method to define mock.On call
//   - ctx context.Context
//   - labels map[string]string
func (_e *MockRepository_Expecter) FindManifests(ctx interface{}, labels interface{}) *MockRepository_FindManifests_Call {
	return &MockRepository_FindManifests_Call{Call: _e.mock.On("FindManifests", ctx, labels)}
}

func (_c *MockRepository_FindManifests_Call) Run(run func(ctx context.Context, labels map[string]string)) *MockRepository_FindManifests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 map[string]string
		if args[1] != nil {
			arg1 = args[1].(map[string]string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_FindManifests_Call) Return(entryMetadatas []*manifest.EntryMetadata, err error) *MockRepository_FindManifests_Call {
	_c.Call.Return(entryMetadatas, err)
	return _c
}

func (_c *MockRepository_FindManifests_Call) RunAndReturn(run func(ctx context.Context, labels map[string]string) ([]*manifest.EntryMetadata, error)) *MockRepository_FindManifests_Call {
	_c.Call.Return(run)
	return _c
}

// GetManifest provides a mock function for the type MockRepository
func (_mock *MockRepository) GetManifest(ctx context.Context, id manifest.ID, data any) (*manifest.EntryMetadata, error) {
	ret := _mock.Called(ctx, id, data)

	if len(ret) == 0 {
		panic("no return value specified for GetManifest")
	}

	var r0 *manifest.EntryMetadata
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, manifest.ID, any) (*manifest.EntryMetadata, error)); ok {
		return returnFunc(ctx, id, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, manifest.ID, any) *manifest.EntryMetadata); ok {
		r0 = returnFunc(ctx, id, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*manifest.EntryMetadata)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, manifest.ID, any) error); ok {
		r1 = returnFunc(ctx, id, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetManifest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetManifest'
type MockRepository_GetManifest_Call struct {
	*mock.Call
}

// GetManifest is a helper method to define mock.On call
//   - ctx context.Context
//   - id manifest.ID
//   - data any
func (_e *MockRepository_Expecter) GetManifest(ctx interface{}, id interface{}, data interface{}) *MockRepository_GetManifest_Call {
	return &MockRepository_GetManifest_Call{Call: _e.mock.On("GetManifest", ctx, id, data)}
}

func (_c *MockRepository_GetManifest_Call) Run(run func(ctx context.Context, id manifest.ID, data any)) *MockRepository_GetManifest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 manifest.ID
		if args[1] != nil {
			arg1 = args[1].(manifest.ID)
		}
		var arg2 any
		if args[2] != nil {
			arg2 = args[2].(any)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_GetManifest_Call) Return(entryMetadata *manifest.EntryMetadata, err error) *MockRepository_GetManifest_Call {
	_c.Call.Return(entryMetadata, err)
	return _c
}

func (_c *MockRepository_GetManifest_Call) RunAndReturn(run func(ctx context.Context, id manifest.ID, data any) (*manifest.EntryMetadata, error)) *MockRepository_GetManifest_Call {
	_c.Call.Return(run)
	return _c
}

// NewWriter provides a mock function for the type MockRepository
func (_mock *MockRepository) NewWriter(ctx context.Context, opt repo.WriteSessionOptions) (context.Context, repo.RepositoryWriter, error) {
	ret := _mock.Called(ctx, opt)

	if len(ret) == 0 {
		panic("no return value specified for NewWriter")
	}

	var r0 context.Context
	var r1 repo.RepositoryWriter
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repo.WriteSessionOptions) (context.Context, repo.RepositoryWriter, error)); ok {
		return returnFunc(ctx, opt)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repo.WriteSessionOptions) context.Context); ok {
		r0 = returnFunc(ctx, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repo.WriteSessionOptions) repo.RepositoryWriter); ok {
		r1 = returnFunc(ctx, opt)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(repo.RepositoryWriter)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, repo.WriteSessionOptions) error); ok {
		r2 = returnFunc(ctx, opt)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockRepository_NewWriter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NewWriter'
type MockRepository_NewWriter_Call struct {
	*mock.Call
}

// NewWriter is a helper method to define mock.On call
//   - ctx context.Context
//   - opt repo.WriteSessionOptions
func (_e *MockRepository_Expecter) NewWriter(ctx interface{}, opt interface{}) *MockRepository_NewWriter_Call {
	return &MockRepository_NewWriter_Call{Call: _e.mock.On("NewWriter", ctx, opt)}
}

func (_c *MockRepository_NewWriter_Call) Run(run func(ctx context.Context, opt repo.WriteSessionOptions)) *MockRepository_NewWriter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repo.WriteSessionOptions
		if args[1] != nil {
			arg1 = args[1].(repo.WriteSessionOptions)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_NewWriter_Call) Return(context1 context.Context, repositoryWriter repo.RepositoryWriter, err error) *MockRepository_NewWriter_Call {
	_c.Call.Return(context1, repositoryWriter, err)
	return _c
}

func (_c *MockRepository_NewWriter_Call) RunAndReturn(run func(ctx context.Context, opt repo.WriteSessionOptions) (context.Context, repo.RepositoryWriter, error)) *MockRepository_NewWriter_Call {
	_c.Call.Return(run)
	return _c
}

// OpenObject provides a mock function for the type MockRepository
func (_mock *MockRepository) OpenObject(ctx context.Context, id object.ID) (object.Reader, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for OpenObject")
	}

	var r0 object.Reader
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, object.ID) (object.Reader, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, object.ID) object.Reader); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(object.Reader)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, object.ID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_OpenObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenObject'
type MockRepository_OpenObject_Call struct {
	*mock.Call
}

// OpenObject is a helper method to define mock.On call
//   - ctx context.Context
//   - id object.ID
func (_e *MockRepository_Expecter) OpenObject(ctx interface{}, id interface{}) *MockRepository_OpenObject_Call {
	return &MockRepository_OpenObject_Call{Call: _e.mock.On("OpenObject", ctx, id)}
}

func (_c *MockRepository_OpenObject_Call) Run(run func(ctx context.Context, id object.ID)) *MockRepository_OpenObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 object.ID
		if args[1] != nil {
			arg1 = args[1].(object.ID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_OpenObject_Call) Return(reader object.Reader, err error) *MockRepository_OpenObject_Call {
	_c.Call.Return(reader, err)
	return _c
}

func (_c *MockRepository_OpenObject_Call) RunAndReturn(run func(ctx context.Context, id object.ID) (object.Reader, error)) *MockRepository_OpenObject_Call {
	_c.Call.Return(run)
	return _c
}

// PrefetchContents provides a mock function for the type MockRepository
func (_mock *MockRepository) PrefetchContents(ctx context.Context, contentIDs []content.ID, hint string) []content.ID {
	ret := _mock.Called(ctx, contentIDs, hint)

	if len(ret) == 0 {
		panic("no return value specified for PrefetchContents")
	}

	var r0 []content.ID
	if returnFunc, ok := ret.Get(0).(func(context.Context, []content.ID, string) []content.ID); ok {
		r0 = returnFunc(ctx, contentIDs, hint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]content.ID)
		}
	}
	return r0
}

// MockRepository_PrefetchContents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PrefetchContents'
type MockRepository_PrefetchContents_Call struct {
	*mock.Call
}

// PrefetchContents is a helper method to define mock.On call
//   - ctx context.Context
//   - contentIDs []content.ID
//   - hint string
func (_e *MockRepository_Expecter) PrefetchContents(ctx interface{}, contentIDs interface{}, hint interface{}) *MockRepository_PrefetchContents_Call {
	return &MockRepository_PrefetchContents_Call{Call: _e.mock.On("PrefetchContents", ctx, contentIDs, hint)}
}

func (_c *MockRepository_PrefetchContents_Call) Run(run func(ctx context.Context, contentIDs []content.ID, hint string)) *MockRepository_PrefetchContents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []content.ID
		if args[1] != nil {
			arg1 = args[1].([]content.ID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_PrefetchContents_Call) Return(vs []content.ID) *MockRepository_PrefetchContents_Call {
	_c.Call.Return(vs)
	return _c
}

func (_c *MockRepository_PrefetchContents_Call) RunAndReturn(run func(ctx context.Context, contentIDs []content.ID, hint string) []content.ID) *MockRepository_PrefetchContents_Call {
	_c.Call.Return(run)
	return _c
}

// PrefetchObjects provides a mock function for the type MockRepository
func (_mock *MockRepository) PrefetchObjects(ctx context.Context, objectIDs []object.ID, hint string) ([]content.ID, error) {
	ret := _mock.Called(ctx, objectIDs, hint)

	if len(ret) == 0 {
		panic("no return value specified for PrefetchObjects")
	}

	var r0 []content.ID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []object.ID, string) ([]content.ID, error)); ok {
		return returnFunc(ctx, objectIDs, hint)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []object.ID, string) []content.ID); ok {
		r0 = returnFunc(ctx, objectIDs, hint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]content.ID)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []object.ID, string) error); ok {
		r1 = returnFunc(ctx, objectIDs, hint)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_PrefetchObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PrefetchObjects'
type MockRepository_PrefetchObjects_Call struct {
	*mock.Call
}

// PrefetchObjects is a helper method to define mock.On call
//   - ctx context.Context
//   - objectIDs []object.ID
//   - hint string
func (_e *MockRepository_Expecter) PrefetchObjects(ctx interface{}, objectIDs interface{}, hint interface{}) *MockRepository_PrefetchObjects_Call {
	return &MockRepository_PrefetchObjects_Call{Call: _e.mock.On("PrefetchObjects", ctx, objectIDs, hint)}
}

func (_c *MockRepository_PrefetchObjects_Call) Run(run func(ctx context.Context, objectIDs []object.ID, hint string)) *MockRepository_PrefetchObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []object.ID
		if args[1] != nil {
			arg1 = args[1].([]object.ID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_PrefetchObjects_Call) Return(vs []content.ID, err error) *MockRepository_PrefetchObjects_Call {
	_c.Call.Return(vs, err)
	return _c
}

func (_c *MockRepository_PrefetchObjects_Call) RunAndReturn(run func(ctx context.Context, objectIDs []object.ID, hint string) ([]content.ID, error)) *MockRepository_PrefetchObjects_Call {
	_c.Call.Return(run)
	return _c
}

// Refresh provides a mock function for the type MockRepository
func (_mock *MockRepository) Refresh(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Refresh")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_Refresh_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Refresh'
type MockRepository_Refresh_Call struct {
	*mock.Call
}

// Refresh is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) Refresh(ctx interface{}) *MockRepository_Refresh_Call {
	return &MockRepository_Refresh_Call{Call: _e.mock.On("Refresh", ctx)}
}

func (_c *MockRepository_Refresh_Call) Run(run func(ctx context.Context)) *MockRepository_Refresh_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockRepository_Refresh_Call) Return(err error) *MockRepository_Refresh_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_Refresh_Call) RunAndReturn(run func(ctx context.Context) error) *MockRepository_Refresh_Call {
	_c.Call.Return(run)
	return _c
}

// Time provides a mock function for the type MockRepository
func (_mock *MockRepository) Time() time.Time {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Time")
	}

	var r0 time.Time
	if returnFunc, ok := ret.Get(0).(func() time.Time); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(time.Time)
	}
	return r0
}

// MockRepository_Time_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Time'
type MockRepository_Time_Call struct {
	*mock.Call
}

// Time is a helper method to define mock.On call
func (_e *MockRepository_Expecter) Time() *MockRepository_Time_Call {
	return &MockRepository_Time_Call{Call: _e.mock.On("Time")}
}

func (_c *MockRepository_Time_Call) Run(run func()) *MockRepository_Time_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRepository_Time_Call) Return(time1 time.Time) *MockRepository_Time_Call {
	_c.Call.Return(time1)
	return _c
}

func (_c *MockRepository_Time_Call) RunAndReturn(run func() time.Time) *MockRepository_Time_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateDescription provides a mock function for the type MockRepository
func (_mock *MockRepository) UpdateDescription(d string) {
	_mock.Called(d)
	return
}

// MockRepository_UpdateDescription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateDescription'
type MockRepository_UpdateDescription_Call struct {
	*mock.Call
}

// UpdateDescription is a helper method to define mock.On call
//   - d string
func (_e *MockRepository_Expecter) UpdateDescription(d interface{}) *MockRepository_UpdateDescription_Call {
	return &MockRepository_UpdateDescription_Call{Call: _e.mock.On("UpdateDescription", d)}
}

func (_c *MockRepository_UpdateDescription_Call) Run(run func(d string)) *MockRepository_UpdateDescription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockRepository_UpdateDescription_Call) Return() *MockRepository_UpdateDescription_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockRepository_UpdateDescription_Call) RunAndReturn(run func(d string)) *MockRepository_UpdateDescription_Call {
	_c.Run(run)
	return _c
}

// VerifyObject provides a mock function for the type MockRepository
func (_mock *MockRepository) VerifyObject(ctx context.Context, id object.ID) ([]content.ID, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for VerifyObject")
	}

	var r0 []content.ID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, object.ID) ([]content.ID, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, object.ID) []content.ID); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]content.ID)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, object.ID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_VerifyObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyObject'
type MockRepository_VerifyObject_Call struct {
	*mock.Call
}

// VerifyObject is a helper method to define mock.On call
//   - ctx context.Context
//   - id object.ID
func (_e *MockRepository_Expecter) VerifyObject(ctx interface{}, id interface{}) *MockRepository_VerifyObject_Call {
	return &MockRepository_VerifyObject_Call{Call: _e.mock.On("VerifyObject", ctx, id)}
}

func (_c *MockRepository_VerifyObject_Call) Run(run func(ctx context.Context, id object.ID)) *MockRepository_VerifyObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 object.ID
		if args[1] != nil {
			arg1 = args[1].(object.ID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_VerifyObject_Call) Return(vs []content.ID, err error) *MockRepository_VerifyObject_Call {
	_c.Call.Return(vs, err)
	return _c
}

func (_c *MockRepository_VerifyObject_Call) RunAndReturn(run func(ctx context.Context, id object.ID) ([]content.ID, error)) *MockRepository_VerifyObject_Call {
	_c.Call.Return(run)
	return _c
}
