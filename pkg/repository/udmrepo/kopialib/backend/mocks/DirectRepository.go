// Code generated by mockery v2.22.1. DO NOT EDIT.

package mocks

import (
	blob "github.com/kopia/kopia/repo/blob"
	content "github.com/kopia/kopia/repo/content"

	context "context"

	format "github.com/kopia/kopia/repo/format"

	index "github.com/kopia/kopia/repo/content/index"

	indexblob "github.com/kopia/kopia/repo/content/indexblob"

	manifest "github.com/kopia/kopia/repo/manifest"

	mock "github.com/stretchr/testify/mock"

	object "github.com/kopia/kopia/repo/object"

	repo "github.com/kopia/kopia/repo"

	throttling "github.com/kopia/kopia/repo/blob/throttling"

	time "time"
)

// DirectRepository is an autogenerated mock type for the DirectRepository type
type DirectRepository struct {
	mock.Mock
}

// AlsoLogToContentLog provides a mock function with given fields: ctx
func (_m *DirectRepository) AlsoLogToContentLog(ctx context.Context) context.Context {
	ret := _m.Called(ctx)

	var r0 context.Context
	if rf, ok := ret.Get(0).(func(context.Context) context.Context); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}

	return r0
}

// BlobReader provides a mock function with given fields:
func (_m *DirectRepository) BlobReader() blob.Reader {
	ret := _m.Called()

	var r0 blob.Reader
	if rf, ok := ret.Get(0).(func() blob.Reader); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(blob.Reader)
		}
	}

	return r0
}

// BlobVolume provides a mock function with given fields:
func (_m *DirectRepository) BlobVolume() blob.Volume {
	ret := _m.Called()

	var r0 blob.Volume
	if rf, ok := ret.Get(0).(func() blob.Volume); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(blob.Volume)
		}
	}

	return r0
}

// ClientOptions provides a mock function with given fields:
func (_m *DirectRepository) ClientOptions() repo.ClientOptions {
	ret := _m.Called()

	var r0 repo.ClientOptions
	if rf, ok := ret.Get(0).(func() repo.ClientOptions); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(repo.ClientOptions)
	}

	return r0
}

// Close provides a mock function with given fields: ctx
func (_m *DirectRepository) Close(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConfigFilename provides a mock function with given fields:
func (_m *DirectRepository) ConfigFilename() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ContentInfo provides a mock function with given fields: ctx, contentID
func (_m *DirectRepository) ContentInfo(ctx context.Context, contentID index.ID) (index.Info, error) {
	ret := _m.Called(ctx, contentID)

	var r0 index.Info
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, index.ID) (index.Info, error)); ok {
		return rf(ctx, contentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, index.ID) index.Info); ok {
		r0 = rf(ctx, contentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(index.Info)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, index.ID) error); ok {
		r1 = rf(ctx, contentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ContentReader provides a mock function with given fields:
func (_m *DirectRepository) ContentReader() content.Reader {
	ret := _m.Called()

	var r0 content.Reader
	if rf, ok := ret.Get(0).(func() content.Reader); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(content.Reader)
		}
	}

	return r0
}

// DeriveKey provides a mock function with given fields: purpose, keyLength
func (_m *DirectRepository) DeriveKey(purpose []byte, keyLength int) []byte {
	ret := _m.Called(purpose, keyLength)

	var r0 []byte
	if rf, ok := ret.Get(0).(func([]byte, int) []byte); ok {
		r0 = rf(purpose, keyLength)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// DisableIndexRefresh provides a mock function with given fields:
func (_m *DirectRepository) DisableIndexRefresh() {
	_m.Called()
}

// FindManifests provides a mock function with given fields: ctx, labels
func (_m *DirectRepository) FindManifests(ctx context.Context, labels map[string]string) ([]*manifest.EntryMetadata, error) {
	ret := _m.Called(ctx, labels)

	var r0 []*manifest.EntryMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, map[string]string) ([]*manifest.EntryMetadata, error)); ok {
		return rf(ctx, labels)
	}
	if rf, ok := ret.Get(0).(func(context.Context, map[string]string) []*manifest.EntryMetadata); ok {
		r0 = rf(ctx, labels)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*manifest.EntryMetadata)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, map[string]string) error); ok {
		r1 = rf(ctx, labels)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FormatManager provides a mock function with given fields:
func (_m *DirectRepository) FormatManager() *format.Manager {
	ret := _m.Called()

	var r0 *format.Manager
	if rf, ok := ret.Get(0).(func() *format.Manager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*format.Manager)
		}
	}

	return r0
}

// GetManifest provides a mock function with given fields: ctx, id, data
func (_m *DirectRepository) GetManifest(ctx context.Context, id manifest.ID, data interface{}) (*manifest.EntryMetadata, error) {
	ret := _m.Called(ctx, id, data)

	var r0 *manifest.EntryMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, manifest.ID, interface{}) (*manifest.EntryMetadata, error)); ok {
		return rf(ctx, id, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, manifest.ID, interface{}) *manifest.EntryMetadata); ok {
		r0 = rf(ctx, id, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*manifest.EntryMetadata)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, manifest.ID, interface{}) error); ok {
		r1 = rf(ctx, id, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IndexBlobs provides a mock function with given fields: ctx, includeInactive
func (_m *DirectRepository) IndexBlobs(ctx context.Context, includeInactive bool) ([]indexblob.Metadata, error) {
	ret := _m.Called(ctx, includeInactive)

	var r0 []indexblob.Metadata
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, bool) ([]indexblob.Metadata, error)); ok {
		return rf(ctx, includeInactive)
	}
	if rf, ok := ret.Get(0).(func(context.Context, bool) []indexblob.Metadata); ok {
		r0 = rf(ctx, includeInactive)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]indexblob.Metadata)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, bool) error); ok {
		r1 = rf(ctx, includeInactive)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewDirectWriter provides a mock function with given fields: ctx, opt
func (_m *DirectRepository) NewDirectWriter(ctx context.Context, opt repo.WriteSessionOptions) (context.Context, repo.DirectRepositoryWriter, error) {
	ret := _m.Called(ctx, opt)

	var r0 context.Context
	var r1 repo.DirectRepositoryWriter
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, repo.WriteSessionOptions) (context.Context, repo.DirectRepositoryWriter, error)); ok {
		return rf(ctx, opt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repo.WriteSessionOptions) context.Context); ok {
		r0 = rf(ctx, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repo.WriteSessionOptions) repo.DirectRepositoryWriter); ok {
		r1 = rf(ctx, opt)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(repo.DirectRepositoryWriter)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, repo.WriteSessionOptions) error); ok {
		r2 = rf(ctx, opt)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NewWriter provides a mock function with given fields: ctx, opt
func (_m *DirectRepository) NewWriter(ctx context.Context, opt repo.WriteSessionOptions) (context.Context, repo.RepositoryWriter, error) {
	ret := _m.Called(ctx, opt)

	var r0 context.Context
	var r1 repo.RepositoryWriter
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, repo.WriteSessionOptions) (context.Context, repo.RepositoryWriter, error)); ok {
		return rf(ctx, opt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repo.WriteSessionOptions) context.Context); ok {
		r0 = rf(ctx, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repo.WriteSessionOptions) repo.RepositoryWriter); ok {
		r1 = rf(ctx, opt)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(repo.RepositoryWriter)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, repo.WriteSessionOptions) error); ok {
		r2 = rf(ctx, opt)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ObjectFormat provides a mock function with given fields:
func (_m *DirectRepository) ObjectFormat() format.ObjectFormat {
	ret := _m.Called()

	var r0 format.ObjectFormat
	if rf, ok := ret.Get(0).(func() format.ObjectFormat); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(format.ObjectFormat)
	}

	return r0
}

// OpenObject provides a mock function with given fields: ctx, id
func (_m *DirectRepository) OpenObject(ctx context.Context, id object.ID) (object.Reader, error) {
	ret := _m.Called(ctx, id)

	var r0 object.Reader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, object.ID) (object.Reader, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, object.ID) object.Reader); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(object.Reader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, object.ID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PrefetchContents provides a mock function with given fields: ctx, contentIDs, hint
func (_m *DirectRepository) PrefetchContents(ctx context.Context, contentIDs []index.ID, hint string) []index.ID {
	ret := _m.Called(ctx, contentIDs, hint)

	var r0 []index.ID
	if rf, ok := ret.Get(0).(func(context.Context, []index.ID, string) []index.ID); ok {
		r0 = rf(ctx, contentIDs, hint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]index.ID)
		}
	}

	return r0
}

// PrefetchObjects provides a mock function with given fields: ctx, objectIDs, hint
func (_m *DirectRepository) PrefetchObjects(ctx context.Context, objectIDs []object.ID, hint string) ([]index.ID, error) {
	ret := _m.Called(ctx, objectIDs, hint)

	var r0 []index.ID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []object.ID, string) ([]index.ID, error)); ok {
		return rf(ctx, objectIDs, hint)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []object.ID, string) []index.ID); ok {
		r0 = rf(ctx, objectIDs, hint)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]index.ID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []object.ID, string) error); ok {
		r1 = rf(ctx, objectIDs, hint)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Refresh provides a mock function with given fields: ctx
func (_m *DirectRepository) Refresh(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Throttler provides a mock function with given fields:
func (_m *DirectRepository) Throttler() throttling.SettableThrottler {
	ret := _m.Called()

	var r0 throttling.SettableThrottler
	if rf, ok := ret.Get(0).(func() throttling.SettableThrottler); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(throttling.SettableThrottler)
		}
	}

	return r0
}

// Time provides a mock function with given fields:
func (_m *DirectRepository) Time() time.Time {
	ret := _m.Called()

	var r0 time.Time
	if rf, ok := ret.Get(0).(func() time.Time); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	return r0
}

// Token provides a mock function with given fields: password
func (_m *DirectRepository) Token(password string) (string, error) {
	ret := _m.Called(password)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(password)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(password)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(password)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UniqueID provides a mock function with given fields:
func (_m *DirectRepository) UniqueID() []byte {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// UpdateDescription provides a mock function with given fields: d
func (_m *DirectRepository) UpdateDescription(d string) {
	_m.Called(d)
}

// VerifyObject provides a mock function with given fields: ctx, id
func (_m *DirectRepository) VerifyObject(ctx context.Context, id object.ID) ([]index.ID, error) {
	ret := _m.Called(ctx, id)

	var r0 []index.ID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, object.ID) ([]index.ID, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, object.ID) []index.ID); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]index.ID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, object.ID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewDirectRepository interface {
	mock.TestingT
	Cleanup(func())
}

// NewDirectRepository creates a new instance of DirectRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewDirectRepository(t mockConstructorTestingTNewDirectRepository) *DirectRepository {
	mock := &DirectRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
