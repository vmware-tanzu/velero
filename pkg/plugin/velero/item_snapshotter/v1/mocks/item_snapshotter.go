// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	context "context"
	mock "github.com/stretchr/testify/mock"

	velero "github.com/vmware-tanzu/velero/pkg/plugin/velero"
	v1 "github.com/vmware-tanzu/velero/pkg/plugin/velero/item_snapshotter/v1"
)

// ItemSnapshotter is an autogenerated mock type for the ItemSnapshotter type
type ItemSnapshotter struct {
	mock.Mock
}

// AlsoHandles provides a mock function with given fields: input
func (_m *ItemSnapshotter) AlsoHandles(input *v1.AlsoHandlesInput) ([]velero.ResourceIdentifier, error) {
	ret := _m.Called(input)

	var r0 []velero.ResourceIdentifier
	if rf, ok := ret.Get(0).(func(*v1.AlsoHandlesInput) []velero.ResourceIdentifier); ok {
		r0 = rf(input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]velero.ResourceIdentifier)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*v1.AlsoHandlesInput) error); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AppliesTo provides a mock function with given fields:
func (_m *ItemSnapshotter) AppliesTo() (velero.ResourceSelector, error) {
	ret := _m.Called()

	var r0 velero.ResourceSelector
	if rf, ok := ret.Get(0).(func() velero.ResourceSelector); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(velero.ResourceSelector)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateItemFromSnapshot provides a mock function with given fields: ctx, input
func (_m *ItemSnapshotter) CreateItemFromSnapshot(ctx context.Context, input *v1.CreateItemInput) (*v1.CreateItemOutput, error) {
	ret := _m.Called(ctx, input)

	var r0 *v1.CreateItemOutput
	if rf, ok := ret.Get(0).(func(context.Context, *v1.CreateItemInput) *v1.CreateItemOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.CreateItemOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *v1.CreateItemInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSnapshot provides a mock function with given fields: ctx, input
func (_m *ItemSnapshotter) DeleteSnapshot(ctx context.Context, input *v1.DeleteSnapshotInput) error {
	ret := _m.Called(ctx, input)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.DeleteSnapshotInput) error); ok {
		r0 = rf(ctx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Init provides a mock function with given fields: config
func (_m *ItemSnapshotter) Init(config map[string]string) error {
	ret := _m.Called(config)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]string) error); ok {
		r0 = rf(config)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Progress provides a mock function with given fields: input
func (_m *ItemSnapshotter) Progress(input *v1.ProgressInput) (*v1.ProgressOutput, error) {
	ret := _m.Called(input)

	var r0 *v1.ProgressOutput
	if rf, ok := ret.Get(0).(func(*v1.ProgressInput) *v1.ProgressOutput); ok {
		r0 = rf(input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.ProgressOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*v1.ProgressInput) error); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SnapshotItem provides a mock function with given fields: ctx, input
func (_m *ItemSnapshotter) SnapshotItem(ctx context.Context, input *v1.SnapshotItemInput) (*v1.SnapshotItemOutput, error) {
	ret := _m.Called(ctx, input)

	var r0 *v1.SnapshotItemOutput
	if rf, ok := ret.Get(0).(func(context.Context, *v1.SnapshotItemInput) *v1.SnapshotItemOutput); ok {
		r0 = rf(ctx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.SnapshotItemOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *v1.SnapshotItemInput) error); ok {
		r1 = rf(ctx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
